<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE TS>
<TS version="2.1" language="zh_CN">
<context>
    <name>ExtraMeshFilterPlugin</name>
    <message>
        <location filename="meshfilter.cpp" line="215"/>
        <source>Subdivision Surfaces: Loop</source>
        <translation>细分表面:循环</translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="216"/>
        <source>Subdivision Surfaces: Butterfly Subdivision</source>
        <translation>细分表面:Butterfly 细分</translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="217"/>
        <source>Subdivision Surfaces: Midpoint</source>
        <translation>细分表面:中点</translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="218"/>
        <source>Subdivision Surfaces: Catmull-Clark</source>
        <translation>细分表面:Catmull-Clark</translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="219"/>
        <source>Simplification: Quadric Edge Collapse Decimation</source>
        <translation>简化:二次边缘折叠抽取</translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="220"/>
        <source>Simplification: Quadric Edge Collapse Decimation (with texture)</source>
        <translation>简化:二次边缘折叠抽取(带纹理)</translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="221"/>
        <source>Remeshing: Isotropic Explicit Remeshing</source>
        <translation>重新网格化：各向同性的明确重新网格化</translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="222"/>
        <source>Simplification: Clustering Decimation</source>
        <translation>简化：聚类抽取</translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="223"/>
        <source>Re-Orient all faces coherentely</source>
        <translation>一致地重新定位所有面</translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="224"/>
        <source>Invert Faces Orientation</source>
        <translation>反转面方向</translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="225"/>
        <source>Transform: Scale, Normalize</source>
        <translation>变换：缩放，标准化</translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="226"/>
        <source>Transform: Translate, Center, set Origin</source>
        <translation>变换：转变，居中，设置原点</translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="227"/>
        <source>Transform: Rotate</source>
        <translation>变换：旋转</translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="228"/>
        <source>Transform: Rotate to Fit to a plane</source>
        <translation>变换：旋转以适合平面</translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="229"/>
        <source>Transform: Align to Principal Axis</source>
        <translation>变换：与主轴对齐</translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="230"/>
        <source>Transform: Flip and/or swap axis</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="231"/>
        <source>Matrix: Freeze Current Matrix</source>
        <translation>矩阵：冻结当前矩阵</translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="232"/>
        <source>Matrix: Reset Current Matrix</source>
        <translation>矩阵：复位当前矩阵</translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="233"/>
        <source>Matrix: Invert Current Matrix</source>
        <translation>矩阵：逆转当前矩阵</translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="234"/>
        <source>Matrix: Set from translation/rotation/scale</source>
        <translation>矩阵:从平移/旋转/缩放设置</translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="235"/>
        <source>Matrix: Set/Copy Transformation</source>
        <translation>矩阵:设置/复制转换</translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="236"/>
        <source>Compute normals for point sets</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="237"/>
        <source>Smooths normals on a point sets</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="238"/>
        <source>Compute curvature principal directions</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="239"/>
        <source>Close Holes</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="240"/>
        <source>Geometric Cylindrical Unwrapping</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="241"/>
        <source>Tri to Quad by 4-8 Subdivision</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="242"/>
        <source>Turn into Quad-Dominant mesh</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="243"/>
        <source>Turn into a Pure-Triangular mesh</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="244"/>
        <source>Tri to Quad by smart triangle pairing</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="245"/>
        <source>Select Crease Edges</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="246"/>
        <source>Build a Polyline from Selected Edges</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="247"/>
        <source>Vertex Attribute Seam</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="248"/>
        <source>Subdivision Surfaces: LS3 Loop</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="249"/>
        <source>Compute Planar Section</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="250"/>
        <source>Create Selection Perimeter Polyline</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="255"/>
        <source>error!</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="262"/>
        <source>Apply LS3 Subdivision Surface algorithm using Loop&apos;s weights. This refinement method take normals into account. &lt;br&gt;See:&lt;i&gt;Boye&apos;, S. Guennebaud, G. &amp; Schlick, C.&lt;/i&gt; &lt;br&gt;&lt;b&gt;Least squares subdivision surfaces&lt;/b&gt;&lt;br&gt;Computer Graphics Forum, 2010.&lt;br/&gt;&lt;br/&gt;Alternatives weighting schemes are based on the paper: &lt;i&gt;Barthe, L. &amp; Kobbelt, L.&lt;/i&gt;&lt;br&gt;&lt;b&gt;Subdivision scheme tuning around extraordinary vertices&lt;/b&gt;&lt;br&gt;Computer Aided Geometric Design, 2004, 21, 561-583.&lt;br/&gt;The current implementation of these schemes don&apos;t handle vertices of valence &gt; 12</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="272"/>
        <source>Apply Loop&apos;s Subdivision Surface algorithm. It is an approximant refinement method and it works for every triangle and has rules for extraordinary vertices.&lt;br&gt;</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="273"/>
        <source>Apply Butterfly Subdivision Surface algorithm. It is an interpolated refinement method, defined on arbitrary triangular meshes. The scheme is known to be C1 but not C2 on regular meshes&lt;br&gt;</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="274"/>
        <source>Apply a plain subdivision scheme where every edge is splitted on its midpoint. Useful to uniformly refine a mesh substituting each triangle with four smaller triangles.</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="275"/>
        <source>Apply the Catmull-Clark Subdivision Surfaces. Note that position of the new vertices is simply linearly interpolated. If the mesh is triangle based (no faux edges) it generates a quad mesh, otherwise it honores it the faux-edge bits</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="276"/>
        <source>Convert a tri mesh into a quad mesh by applying a 4-8 subdivision scheme.It introduces less overhead than the plain Catmull-Clark Subdivision Surfaces(it adds only a single vertex for each triangle instead of four).&lt;br&gt; See: &lt;br&gt;&lt;b&gt;4-8 Subdivision&lt;/b&gt;&lt;br&gt; &lt;i&gt;Luiz Velho, Denis Zorin &lt;/i&gt;&lt;br&gt;CAGD, volume 18, Issue 5, Pages 397-427. </source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="283"/>
        <source>Collapse vertices by creating a three dimensional grid enveloping the mesh and discretizes them based on the cells of this grid</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="284"/>
        <source>Simplify a mesh using a Quadric based Edge Collapse Strategy; better than clustering but slower</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="285"/>
        <source>Simplify a textured mesh using a Quadric based Edge Collapse Strategy preserving UV parametrization; better than clustering but slower</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="286"/>
        <source>Perform a explict remeshing of a triangular mesh, by repeatedly applying edge flip, collapse, relax and refine to improve aspect ratio (triangle quality) and topological regularity.</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="287"/>
        <source>Re-orient in a consistent way all the faces of the mesh. &lt;br&gt;The filter visits a mesh face to face, reorienting any unvisited face so that it is coherent to the already visited faces. If the surface is orientable it will end with a consistent orientation of all the faces. If the surface is not orientable (e.g. it is non manifold or non orientable like a moebius strip) the filter will not build a consistent orientation simply because it is not possible. The filter can end up in a consistent orientation that can be exactly the opposite of the expected one; in that case simply invert the whole mesh orientation.</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="292"/>
        <source>Invert faces orientation, flipping the normals of the mesh. &lt;br&gt;If requested, it tries to guess the right orientation; mainly it decide to flip all the faces if the minimum/maximum vertexes have not outward point normals for a few directions.&lt;br&gt;Works well for single component watertight objects.</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="296"/>
        <source>Generate a matrix transformation that scale the mesh. The mesh can be also automatically scaled to a unit side box. </source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="297"/>
        <source>Generate a matrix transformation that translate the mesh. The mesh can be translated around one of the axis or a given axis and w.r.t. to the origin or the baricenter, or a given point.</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="298"/>
        <source>Generate a matrix transformation that rotates the mesh. The mesh can be rotated around one of the axis or a given axis and w.r.t. to the origin or the baricenter, or a given point.</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="299"/>
        <source>Generate a matrix transformation that rotates the mesh so that the selection fits one of the main planes XY YZ ZX. May also translate such that the selection centroid rest on the origin. It reports on the log the average error of the fitting (in mesh units).</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="300"/>
        <source>Generate a matrix transformation that rotates the mesh aligning it to its principal axis of inertia.If the mesh is watertight the Itertia tensor is computed assuming the interior of the mesh has a uniform density.In case of an open mesh or a point clouds the inerta tensor is computed assuming each vertex is a constant puntual mass.</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="303"/>
        <source>Generate a matrix transformation that flips each one of the axis or swaps a couple of axis. The listed transformations are applied in that order. This kind of transformation cannot be applied to set of Raster!</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="304"/>
        <source>Set the current transformation matrix to the Identity. </source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="305"/>
        <source>Freeze the current transformation matrix into the coordinates of the vertices of the mesh (and set this matrix to the identity). In other words it applies in a definetive way the current matrix to the vertex coordinates.</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="306"/>
        <source>Invert the current transformation matrix. The current transformation is reversed, becoming its opposite.</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="307"/>
        <source>Set the current transformation matrix starting from parameters: [XYZ] translation, [XYZ] Euler angles rotation and [XYZ] scaling.</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="308"/>
        <source>Set the current transformation matrix by filling it, or copying from another layer.</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="309"/>
        <source>Compute the normals of the vertices of a mesh without exploiting the triangle connectivity, useful for dataset with no faces</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="310"/>
        <source>Smooth the normals of the vertices of a mesh without exploiting the triangle connectivity, useful for dataset with no faces</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="311"/>
        <source>Compute the principal directions of curvature with several algorithms</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="312"/>
        <source>Close holes smaller than a given threshold</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="313"/>
        <source>Unwrap the geometry of current mesh along a clylindrical equatorial projection. The cylindrical projection axis is centered on the origin and directed along the vertical &lt;b&gt;Y&lt;/b&gt; axis.</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="314"/>
        <source>Convert a tri-mesh into a quad mesh by pairing triangles.</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="315"/>
        <source>Convert a tri-mesh into a quad-dominant mesh by pairing suitable triangles.</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="316"/>
        <source>Convert into a tri-mesh by splitting any polygonal face.</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="317"/>
        <source>It select the crease edges of a mesh according to edge dihedral angle.&lt;br&gt;Angle between face normal is considered signed according to convexity/concavity.Convex angles are positive and concave are negative.</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="320"/>
        <source>Make all selected vertex attributes connectivity-independent:&lt;br/&gt;vertices are duplicated whenever two or more selected wedge or face attributes do not match.&lt;br/&gt;This is particularly useful for GPU-friendly mesh layout, where a single index must be used to access all required vertex attributes.</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="323"/>
        <source>Compute the polyline representing a planar section (a slice) of a mesh; if the resulting polyline is closed the result is filled and also a triangular mesh representing the section is saved</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="324"/>
        <source>Create a new Layer with the perimeter polyline(s) of the selection borders</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="325"/>
        <source>Create a new Layer with an edge mesh composed only by the selected edges of the current mesh</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="353"/>
        <source>Method:</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="353"/>
        <location filename="meshfilter.cpp" line="510"/>
        <location filename="meshfilter.cpp" line="515"/>
        <location filename="meshfilter.cpp" line="558"/>
        <location filename="meshfilter.cpp" line="590"/>
        <location filename="meshfilter.cpp" line="592"/>
        <location filename="meshfilter.cpp" line="594"/>
        <source>Choose a method</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="354"/>
        <source>Quality/Color Mapping</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="510"/>
        <source>Rotation on:</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="515"/>
        <source>Center of rotation:</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="538"/>
        <source>Transformation:</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="538"/>
        <source>[XYZ translation] adds X,Y and Z offset to Layer transformation, [Center on BBox] moves Layer Origin to the Bounding Box center, [Set new Origin] moves Layer Origin to a specific point</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="558"/>
        <source>Center of scaling:</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="590"/>
        <source>Normal Source:</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="592"/>
        <source>Color Source:</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="594"/>
        <source>Texcoord Source:</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="605"/>
        <source>Plane perpendicular to</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="605"/>
        <source>The Slicing plane will be done perpendicular to the axis</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="616"/>
        <source>Optimize For:</source>
        <translation type="unfinished"></translation>
    </message>
    <message>
        <location filename="meshfilter.cpp" line="616"/>
        <source>Choose any of three different greedy strategies.</source>
        <translation type="unfinished"></translation>
    </message>
</context>
</TS>
